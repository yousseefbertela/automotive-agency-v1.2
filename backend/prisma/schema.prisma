datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum QuoteStatus {
  OPEN
  CONFIRMED
  CANCELLED
  CLOSED
}

enum Channel {
  TELEGRAM
  WHATSAPP
  FRONTEND
}

enum IntegrationService {
  OCR
  OPENAI
  ODOO
  SCRAPER
  TELEGRAM
  WHATSAPP
}

enum IntegrationStatus {
  SUCCESS
  ERROR
}

model Tenant {
  id         String    @id
  name       String?
  status     String    @default("active")
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt

  // Per-tenant Odoo (SaaS: one Odoo account per client). If set, used instead of env ODOO_*.
  odoo_url      String?
  odoo_db       String?
  odoo_username String?
  odoo_password String?

  users               User[]
  sessions            Session[]
  inboundEvents       InboundEvent[]
  integrationLog      IntegrationCall[]
  sessionLinks        SessionLink[]
  pendingNotifications PendingNotification[]
}

model User {
  id         String    @id @default(cuid())
  chat_id    String    @unique
  tenant_id  String
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt

  tenant        Tenant         @relation(fields: [tenant_id], references: [id])
  sessions      Session[]
  inboundEvents InboundEvent[]
  integrationLog IntegrationCall[]
}

model Session {
  chat_id         String   @id
  tenant_id       String
  user_id         String
  vin             String?
  vehicle_info    Json?
  quotation_id    Int?
  basket          Json?
  history         Json?
  customer_name   String?
  customer_phone  String?

  // State machine fields
  pending_action  String?   // CONFIRM_PART_MATCH | CONFIRM_KIT | AWAIT_KIT_CLARIFICATION | COLLECT_CUSTOMER_DATA | CONFIRM_VIN_CHANGE | ADD_MORE_ITEMS | AWAIT_NEXT_PART_NAME | CHOOSE_PRODUCT
  pending_payload Json?     // serialized payload for resume
  expires_at      DateTime? // TTL for pending state (null = no expiry)
  last_step       String?   // last executed step name (debugging)
  channel         String?   // "frontend_agent" | "whatsapp_customer"

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  tenant Tenant @relation(fields: [tenant_id], references: [id])
  user   User   @relation(fields: [user_id], references: [id])
}

model Quote {
  id             String        @id @default(cuid())
  quotation_id   Int?
  customer_name  String?
  customer_phone String?
  vin            String
  vehicle_details Json?
  x_car_id       Int?
  chat_id        String
  status         QuoteStatus   @default(OPEN)
  created_at     DateTime      @default(now())
  updated_at     DateTime      @updatedAt

  basketItems   BasketItem[]
  messages      Message[]
  inboundEvents InboundEvent[]
  statusHistory QuoteStatusHistory[]
  integrationLog IntegrationCall[]

  @@index([status, chat_id])
  @@index([status, chat_id, vin])
}

model BasketItem {
  id               String    @id @default(cuid())
  quote_id         String
  part_number      String
  products         Json
  chosen_product_id Int?
  total_cost       Float?
  created_at       DateTime  @default(now())
  updated_at       DateTime  @updatedAt

  quote Quote @relation(fields: [quote_id], references: [id], onDelete: Cascade)

  @@unique([quote_id, part_number])
}

model CatalogResult {
  id         String   @id @default(cuid())
  type_code  String?
  series     String?
  model      String?
  engine     String?
  group_name String
  subgroups  Json
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([group_name, type_code])
}

model Message {
  id        String   @id
  quote_id  String
  created_at DateTime @default(now())

  quote Quote @relation(fields: [quote_id], references: [id], onDelete: Cascade)
}

model InboundEvent {
  id          String   @id @default(cuid())
  channel     Channel
  external_id String?
  chat_id     String
  tenant_id   String?
  user_id     String?
  quote_id    String?
  event_type  String
  payload     Json
  received_at DateTime @default(now())

  tenant Tenant? @relation(fields: [tenant_id], references: [id])
  user   User?   @relation(fields: [user_id], references: [id])
  quote  Quote?  @relation(fields: [quote_id], references: [id])

  @@index([channel, chat_id, received_at])
  @@index([external_id])
}

model QuoteStatusHistory {
  id          String       @id @default(cuid())
  quote_id    String
  from_status QuoteStatus?
  to_status   QuoteStatus
  channel     Channel
  reason      String?
  meta        Json?
  created_at  DateTime     @default(now())

  quote Quote @relation(fields: [quote_id], references: [id], onDelete: Cascade)

  @@index([quote_id, created_at])
}

model IntegrationCall {
  id           String            @id @default(cuid())
  tenant_id    String?
  user_id      String?
  quote_id     String?
  service      IntegrationService
  operation    String
  request_meta Json?
  response_meta Json?
  status       IntegrationStatus
  duration_ms  Int?
  created_at   DateTime          @default(now())

  tenant Tenant? @relation(fields: [tenant_id], references: [id])
  user   User?   @relation(fields: [user_id], references: [id])
  quote  Quote?  @relation(fields: [quote_id], references: [id])

  @@index([service, created_at])
  @@index([tenant_id, created_at])
}

// Links an agent Frontend session to a tenant (for SSE push routing)
model SessionLink {
  id               String   @id @default(cuid())
  tenant_id        String
  agent_session_id String   // Frontend session UUID
  last_seen        DateTime @default(now())
  created_at       DateTime @default(now())

  tenant Tenant @relation(fields: [tenant_id], references: [id])

  @@index([tenant_id, last_seen])
  @@index([agent_session_id])
}

// Fallback notifications when no SSE connection is active
model PendingNotification {
  id         String   @id @default(cuid())
  tenant_id  String
  event_type String   // order_confirmed | order_cancelled | notification
  data       Json
  delivered  Boolean  @default(false)
  created_at DateTime @default(now())

  tenant Tenant @relation(fields: [tenant_id], references: [id])

  @@index([tenant_id, delivered, created_at])
}

// ── Execution Tracer ──────────────────────────────────────────────────────────

// One TraceRun per incoming message processed through processUserMessage.
// status: RUNNING | SUCCESS | ERROR
model TraceRun {
  id             String      @id @default(cuid())
  session_id     String
  chat_id        String
  tenant_id      String?
  correlation_id String      @unique
  started_at     DateTime    @default(now())
  ended_at       DateTime?
  status         String      @default("RUNNING")

  events TraceEvent[]

  @@index([session_id, started_at])
  @@index([chat_id, started_at])
  @@index([started_at])
}

// One TraceEvent per named step within a TraceRun.
// status: success | error
// replay_safe: true = can be replayed without real-world side effects (AI, Sheets, DB)
//              false = contacts WhatsApp / Odoo (real customers/ERP)
model TraceEvent {
  id           String   @id @default(cuid())
  trace_run_id String
  sequence     Int
  step_name    String
  domain       String   @default("general")
  timestamp    DateTime @default(now())
  duration_ms  Int?
  status       String   @default("success")
  replay_safe  Boolean  @default(false)
  input_json   Json?
  output_json  Json?
  error_json   Json?

  run TraceRun @relation(fields: [trace_run_id], references: [id], onDelete: Cascade)

  @@index([trace_run_id, sequence])
}
